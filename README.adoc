# lab
#### link:../main/container_of.c[container_of.c] module
image:images/container_of.png[alt text]

#### link:../main/container_of_container_of.c[container_of_container_of.c] module
image:images/container_of_container_of.png[alt text]

#### link:../main/list.c[list.c] module
image:images/list.png[alt text]

#### link:../main/hashtable.c[hashtable.c] module
image:images/hashtable.png[alt text]

#### link:../main/phone_table.c[phone_table.c] module
image:images/phone_table.png[alt text]

#### link:../main/wait_queue.c[wait_queue.c] module
*please* read header comment in wait_queue.c to refresh your knowledge.

#### link:../main/wait_queue_proc.c[wait_queue_proc.c] module
image:images/wait_queue_proc.png[alt text]

#### link:../main/waitqueue2.c[waitqueue2.c] module
Another example for *static* waitqueue

How to use: (watch dmesg live)
----
$ sudo insmod waitqueue2.ko
$ sudo cat /dev/etx_device
$ rmmod waitqueue2
----
link:../main/waitqueue3.c[here] is a *dynamic* version.

#### link:../main/params.c[params.c] module
Passing Arguments to Device Driver. like: argc & argv

use:
[source,bash]
----
$ insmod params.ko myshort=5 myint=100 mystring="Sohaib" myintArray=3,7
----

#### link:../main/cb_params.c[cb_params.c] module
Register the callback whenever the argument (parameter) got changed. 
----
$ insmod cb_params.ko myint=50
$ echo 333 > /sys/module/cb_params/parameters/myint
----
image:images/cb_params.png[alt text]


#### link:../main/cdev.c[cdev.c] module
Complete char device driver.

to test the driver use: 
----
$ ./test_cdev
----
image:images/cdev.png[alt text]

#### link:../main/sys_fs.c[sys_fs.c] module
What's sys fs as a system admin?
please see `Documentation/filesystems/sysfs.rst` and `Documentation/core-api/kobject.rst`

How to use:
----
$ insmod sys_fs.ko
$ ls /sys/kernel/sma_sysfs/
$ cat /sys/kernel/sma_sysfs/sma_value
$ echo 44 > /sys/kernel/sma_sysfs/sma_value
$ cat /sys/kernel/sma_sysfs/sma_value
$ rmmod sys_fs
----

#### link:../main/ioctl.c[ioctl.c] module
How to use:
----
$ insmod ioctl.ko
$ ./test_ioctl
----

Nice example from other people:

* https://github.com/smalinux/km-session
* https://github.com/smalinux/linux-kernel-module-cheat/blob/master/kernel_modules/ioctl.c

please see 

* `Documentation/driver-api/ioctl.rst`
* ioctl man page
* https://stackoverflow.com/questions/15807846/ioctl-linux-device-driver
* Google: ioctl linux kernel

#### link:../main/kthread.c[kthread.c] module
How to use: (watch dmesg live)
----
$ insmod kthread.ko
----
See your kernel thread:
----
$ ps -aux | grep "SMA Thread"
----

#### link:../main/export_symbols.c[export_symbols.c] and link:../main/use_symbols.c[use_symbols.c] modules
*export_symbols.c* shares some dummy symbols (variables & functions).

*use_symbols.c* uses these dummy symbols.
Use: (insert and remove use_symbols.ko many times and watch dmesg)
----
$ insmod export_symbols.ko
$ insmod use_symbols.ko
$ rmmod use_symbols
$ insmod use_symbols.ko
$ rmmod use_symbols
$ insmod use_symbols.ko
$ rmmod use_symbols
----
Check if your symbols really engaged to your kernel:
----
$ cat /proc/kallsyms | grep SOHAIB_
$ cat /proc/kallsyms | grep sohaib_
----
I made a very nice trick :D see `link:../main/trick_kallysms.c[trick_kallysms.c]` module.

After inserting `export_symbols.c` module I took the address of `SOHAIB_CONUT` symbol from `/proc/kallsyms` file, then I used it as a hard code in `trick_kallysms.c` :))

#### link:../main/mutex.c[mutex.c] module
This code snippet explains how to create two threads that access a global variable (etx_gloabl_variable). So before accessing the variable, it should lock the mutex. After that, it will release the mutex.

`insmod mutex.ko` and enjoy watching dmesg live.
























 
