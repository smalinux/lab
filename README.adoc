# lab

How to watch dmesg live ?!

run this script: `sudo sh printk_live.sh`

### link:../main/container_of.c[container_of.c] module
Simple use of `container_of` macro.

### link:../main/container_of_container_of.c[container_of_container_of.c] module
I tried to make things more complicated by accessing the `container_of` of the `container_of` struct. `insmod` it & `dmesg`.

### link:../main/list.c[list.c] module
Simple example on `<linux/list.h>`. `insmod` it & `dmesg`.

### link:../main/hashtable.c[hashtable.c] module
Simple example on `<linux/hashtable.h>`. `insmod` it & `dmesg`.

### link:../main/phone_table.c[phone_table.c] module
Another example on `<linux/hashtable.h>`. `insmod` it & `dmesg`.

### link:../main/wait_queue.c[wait_queue.c] module
*please* read header comment in wait_queue.c to refresh your knowledge.

##### link:../main/wait_queue_proc.c[wait_queue_proc.c] module
Use: (*watch dmesg live*)
----
$ insmod wait_queue.ko &
$ echo "hi" > /proc/mydev &
$ echo "bla" > /proc/mydev &
$ rmmod wait_queue.ko
----

##### link:../main/waitqueue2.c[waitqueue2.c] module
Another example for *static* waitqueue

Use: (watch dmesg live)
----
$ sudo insmod waitqueue2.ko
$ sudo cat /dev/etx_device
$ rmmod waitqueue2
----
link:../main/waitqueue3.c[here] is a *dynamic* version.

### link:../main/params.c[params.c] module
Passing Arguments to Device Driver. like: argc & argv

Use:
[source,bash]
----
$ insmod params.ko myshort=5 myint=100 mystring="Sohaib" myintArray=3,7
----

### link:../main/cb_params.c[cb_params.c] module
Register the callback whenever the argument (parameter) got changed. 

insmod & enjoy watching dmesg live!
----
$ insmod cb_params.ko myint=50
$ echo 333 > /sys/module/cb_params/parameters/myint
----

### link:../main/cdev.c[cdev.c] module
Complete char device driver with user-level app for testing.

to test the driver: 
----
$ ./test_cdev
----

### link:../main/sys_fs.c[sys_fs.c] module
What's sys fs as a system admin?
please see `Documentation/filesystems/sysfs.rst` and `Documentation/core-api/kobject.rst`

Use:
----
$ insmod sys_fs.ko
$ ls /sys/kernel/sma_sysfs/
$ cat /sys/kernel/sma_sysfs/sma_value
$ echo 44 > /sys/kernel/sma_sysfs/sma_value
$ cat /sys/kernel/sma_sysfs/sma_value
$ rmmod sys_fs
----

### link:../main/ioctl.c[ioctl.c] module
Use:
----
$ insmod ioctl.ko
$ ./test_ioctl
----

Nice example from other people:

* https://github.com/smalinux/km-session
* https://github.com/smalinux/linux-kernel-module-cheat/blob/master/kernel_modules/ioctl.c

please see 

* `Documentation/driver-api/ioctl.rst`
* ioctl man page
* https://stackoverflow.com/questions/15807846/ioctl-linux-device-driver
* Google: ioctl linux kernel

### link:../main/kthread.c[kthread.c] module
Use: (watch dmesg live)
----
$ insmod kthread.ko
----
See your kernel thread:
----
$ ps -aux | grep "SMA Thread"
----

### link:../main/export_symbols.c[export_symbols.c] and link:../main/use_symbols.c[use_symbols.c] modules
*export_symbols.c* shares some dummy symbols (variables & functions).

*use_symbols.c* uses these dummy symbols.
Use: (insert and remove use_symbols.ko many times and watch dmesg)
----
$ insmod export_symbols.ko
$ insmod use_symbols.ko
$ rmmod use_symbols
$ insmod use_symbols.ko
$ rmmod use_symbols
$ insmod use_symbols.ko
$ rmmod use_symbols
----
Check if your symbols really engaged to your kernel:
----
$ cat /proc/kallsyms | grep SOHAIB_
$ cat /proc/kallsyms | grep sohaib_
----
I made a very nice trick :D see `link:../main/trick_kallysms.c[trick_kallysms.c]` module.

After inserting `export_symbols.c` module I took the address of `SOHAIB_CONUT` symbol from `/proc/kallsyms` file, then I used it as a hard code in `trick_kallysms.c` :))

### link:../main/mutex.c[mutex.c] module
How to use it: `insmod mutex.ko` and enjoy watching dmesg live.

Prerequisites: Make should you understand link:https://github.com/smalinux/lab#kthreadc-module[Kthread].

This code snippet explains how to create two threads that access a global variable (etx_gloabl_variable). So before accessing the variable, it should lock the mutex. After that, it will release the mutex.

This way is *not* the most optimal way for locking, because whole the critical section is just singel int var, and you used *mutex* for locking, this adds moree overhead, the best way here is to use `link:https://github.com/smalinux/lab#atomicc-module[Atomic ops]`.

### link:../main/atomic.c[atomic.c] module
Trivial example touchs some `Atomic ops APIs`.

link:../main/atomic2.c[Another] nice example. `insmod` it and `dmesg` it live..

### link:../main/spinlock.c[spinlock.c] module
How to use it: `insmod spinlock.ko` and enjoy watching dmesg live.

Prerequisites: Make should you understand link:https://github.com/smalinux/lab#kthreadc-module[Kthread].

This code snippet explains how to create two threads that access a global variable (etx_gloabl_variable). So before accessing the variable, it should lock the spinlock. After that, it will release the spinlock.

Here is link:../main/rwlock.c[Read write spinlock] example. `insmod` it and `dmesg` it live..

Here is link:../main/seqlock.c[seqlock.c] example. `insmod` it and `dmesg` it live..

Reference:

* `Documentation/kernel-hacking/locking.rst`
* `Documentation/locking/spinlocks.rst`
* `Documentation/locking/locktypes.rst`



### Workqueue
part 1: https://embetronicx.com/tutorials/linux/device-drivers/workqueue-in-linux-kernel/

part 2: https://embetronicx.com/tutorials/linux/device-drivers/workqueue-in-linux-dynamic-creation/

own workqueue: https://embetronicx.com/tutorials/linux/device-drivers/work-queue-in-linux-own-workqueue/

### Tasklets
Two articles

tasklet.c <- trivial example

tasklet2.c embetronicx example














 
